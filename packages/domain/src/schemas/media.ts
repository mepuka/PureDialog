import { Schema } from "effect"
import { JobId, MediaResourceId } from "./ids.js"
import { SpeakerRole } from "./speakers.js"

/**
 * A specific, branded type for ISO 639-1 language codes (e.g., "en", "es").
 */
export const LanguageCode = Schema.String.pipe(
  Schema.pattern(/^[a-z]{2}(-[A-Z]{2})?$/),
  Schema.brand("LanguageCode")
)
export type LanguageCode = Schema.Schema.Type<typeof LanguageCode>

/**
 * A structured representation of a single speaker identified in the media.
 * This is a core entity within the metadata.
 */
export const Speaker = Schema.Struct({
  // A unique identifier for this speaker within the context of this job (e.g., "S1", "S2")
  // this can also be generated by the model if we want to do lower level dialog parsing
  // likely the case for beyond 1:1 interviews
  role: SpeakerRole,
  name: Schema.optional(Schema.String),
  // Providing a structured object for affiliation is more extensible
  affiliation: Schema.optional(
    Schema.Struct({
      name: Schema.String,
      url: Schema.optional(Schema.String.pipe(Schema.pattern(/^https?:\/\//)))
    })
  ),
  bio: Schema.optional(Schema.String)
})
export type Speaker = Schema.Schema.Type<typeof Speaker>

const MediaFormat = Schema.Literal(
  "one_on_one_interview",
  "lecture",
  "panel_discussion",
  "tv_intervew",
  "radio_interview"
)

/**
 * The canonical MediaMetadata entity.
 * This is the complete, structured context extracted from a MediaResource
 * before the transcription process begins.
 */
export const MediaMetadata = Schema.Struct({
  mediaResourceId: MediaResourceId,
  jobId: JobId,
  title: Schema.String.pipe(
    Schema.nonEmptyString(),
    Schema.annotations({
      description: "The title of the media resource e.g. 'The Future of AI'"
    })
  ),
  organization: Schema.optional(Schema.String.pipe(
    Schema.annotations({
      description: "The organization affiliation of the media resource e.g. 'AI Now Institute'"
    })
  )),
  format: MediaFormat,
  summary: Schema.optional(Schema.String.pipe(
    Schema.annotations({
      description:
        "A summary of the content of the media resource e.g. 'This podcast episode covers the recent advancements in AI'"
    })
  )),
  // Keywords/tags provide crucial context for the ASR model's vocabulary.
  tags: Schema.Array(Schema.String).pipe(
    Schema.annotations({
      description: "Keywords/tags that describe the content of the media resource e.g. 'AI', 'Technology'"
    })
  ),
  // The specific industry or topic domain is vital for improving accuracy.
  domain: Schema.Array(Schema.String).pipe(
    Schema.annotations({
      description: "The industries or topic domains of the media resource e.g. 'AI', 'Technology'"
    })
  ),
  speakers: Schema.Array(Speaker).pipe(
    Schema.annotations({
      description: "The speakers in the media resource e.g. 'John Doe', 'Jane Smith'"
    })
  ),
  language: LanguageCode,
  speakerCount: Schema.Int,
  durationSec: Schema.Number.pipe(Schema.positive()),
  // represents any links found in the media resource (links in youtube description, etc.)
  links: Schema.Array(Schema.String.pipe(Schema.pattern(/^https?:\/\//))).pipe(
    Schema.annotations({
      description: "Links found in the media resource e.g. 'https://www.youtube.com/watch?v=dQw4w9WgXc'"
    })
  ), //
  createdAt: Schema.Date
})
export type MediaMetadata = Schema.Schema.Type<typeof MediaMetadata>

/** A unique identifier for a YouTube video (11 characters). */
export const YouTubeVideoId = Schema.String.pipe(
  Schema.minLength(11),
  Schema.maxLength(11),
  Schema.pattern(/^[a-zA-Z0-9_-]+$/),
  Schema.brand("YouTubeVideoId")
)
export type YouTubeVideoId = Schema.Schema.Type<typeof YouTubeVideoId>

/** A unique identifier for a YouTube channel (24 characters starting with UC). */
export const YouTubeChannelId = Schema.String.pipe(
  Schema.minLength(24),
  Schema.maxLength(24),
  Schema.pattern(/^UC[a-zA-Z0-9_-]+$/),
  Schema.brand("YouTubeChannelId")
)
export type YouTubeChannelId = Schema.Schema.Type<typeof YouTubeChannelId>

/** Clean domain representation of a YouTube video resource. */
export class YouTubeVideo extends Schema.Class<YouTubeVideo>("YouTubeVideo")({
  id: YouTubeVideoId,
  title: Schema.String,
  description: Schema.optional(Schema.String),
  duration: Schema.Number, // seconds
  channelId: Schema.String,
  tags: Schema.Array(Schema.String),
  channelTitle: Schema.String,
  publishedAt: Schema.optional(Schema.String),
  language: Schema.optional(Schema.String).pipe(
    Schema.withConstructorDefault(() => "en-US")
  )
}) {}

/** Clean domain representation of a YouTube channel resource. */
export class YouTubeChannel extends Schema.Class<YouTubeChannel>("YouTubeChannel")({
  id: YouTubeChannelId,
  title: Schema.String,
  description: Schema.optional(Schema.String),
  customUrl: Schema.optional(Schema.String),
  publishedAt: Schema.String,
  country: Schema.optional(Schema.String),
  subscriberCount: Schema.optional(Schema.Number)
}) {}

export class YouTubeVideoResource extends Schema.Class<YouTubeVideoResource>("YouTubeVideoResource")({
  type: Schema.Literal("youtube"),
  id: MediaResourceId,
  metadata: MediaMetadata,
  data: YouTubeVideo
}) {}

export class YouTubeChannelResource extends Schema.Class<YouTubeChannelResource>("YouTubeChannelResource")({
  type: Schema.Literal("youtube-channel"),
  id: MediaResourceId,
  metadata: MediaMetadata,
  data: YouTubeChannel
}) {}

/** MediaResource as discriminated union with clean {type, data} structure. */
export const MediaResource = Schema.Union(
  YouTubeVideoResource,
  YouTubeChannelResource
  // Future: add other media types like Spotify, etc.
)
export type MediaResource = YouTubeVideoResource | YouTubeChannelResource
