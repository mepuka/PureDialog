import { Schema } from "effect"
import { JobId, MediaResourceId } from "./ids.js"
import { SpeakerRole } from "./speakers.js"

/**
 * MediaResource as discriminated union with clean {type, data} structure.
 * This is the core type that all APIs should consume for media content.
 *
 * Design: Simple {type, data} structure for easy consumption by all services.
 * Future: Will be extended to support Spotify, Podcast, etc.
 */
// Import YouTube schemas directly to avoid circular dependencies
import { YouTubeChannel, YouTubeVideo } from "./youtube.js"

/**
 * A specific, branded type for ISO 639-1 language codes (e.g., "en", "es").
 */
export const LanguageCode = Schema.String.pipe(
  Schema.pattern(/^[a-z]{2}(-[A-Z]{2})?$/),
  Schema.brand("LanguageCode")
)
export type LanguageCode = Schema.Schema.Type<typeof LanguageCode>

/**
 * A structured representation of a single speaker identified in the media.
 * This is a core entity within the metadata with improved optional handling.
 */
export const Speaker = Schema.Struct({
  // A unique identifier for this speaker within the context of this job (e.g., "S1", "S2")
  // this can also be generated by the model if we want to do lower level dialog parsing
  // likely the case for beyond 1:1 interviews
  role: SpeakerRole,
  name: Schema.optional(Schema.String.pipe(
    Schema.minLength(1),
    Schema.annotations({
      description: "The speaker's name (required if provided)"
    })
  )),
  // Providing a structured object for affiliation is more extensible
  affiliation: Schema.optional(
    Schema.Struct({
      name: Schema.String.pipe(
        Schema.nonEmptyString(),
        Schema.annotations({
          description: "The organization or affiliation name"
        })
      ),
      url: Schema.optional(
        Schema.String.pipe(
          Schema.pattern(/^https?:\/\/.+/),
          Schema.annotations({
            description: "Valid HTTP/HTTPS URL for the affiliation"
          })
        )
      )
    }).annotations({
      description: "Organizational affiliation information for the speaker"
    })
  ),
  bio: Schema.optional(
    Schema.String.pipe(
      Schema.minLength(1),
      Schema.annotations({
        description: "Biographical information about the speaker"
      })
    )
  )
}).annotations({
  description: "Structured speaker information with role and optional details"
})
export type Speaker = Schema.Schema.Type<typeof Speaker>

const MediaFormat = Schema.Literal(
  "one_on_one_interview",
  "lecture",
  "panel_discussion",
  "tv_intervew",
  "radio_interview"
)

/**
 * The canonical MediaMetadata entity with improved optional parameter handling.
 * This is the complete, structured context extracted from a MediaResource
 * before the transcription process begins.
 */
export const MediaMetadata = Schema.Struct({
  mediaResourceId: MediaResourceId,
  jobId: JobId,
  title: Schema.String.pipe(
    Schema.nonEmptyString(),
    Schema.annotations({
      description: "The title of the media resource e.g. 'The Future of AI'"
    })
  ),
  organization: Schema.optional(
    Schema.String.pipe(
      Schema.nonEmptyString(),
      Schema.annotations({
        description: "The organization affiliation of the media resource e.g. 'AI Now Institute'"
      })
    )
  ),
  format: MediaFormat,
  summary: Schema.optional(
    Schema.String.pipe(
      Schema.nonEmptyString(),
      Schema.annotations({
        description:
          "A summary of the content of the media resource e.g. 'This podcast episode covers the recent advancements in AI'"
      })
    )
  ),
  // Keywords/tags provide crucial context for the ASR model's vocabulary.
  tags: Schema.Array(
    Schema.String.pipe(
      Schema.nonEmptyString(),
      Schema.annotations({
        description: "Individual keyword/tag describing the media content"
      })
    )
  ).pipe(
    Schema.minItems(1),
    Schema.annotations({
      description: "Keywords/tags that describe the content of the media resource e.g. 'AI', 'Technology'"
    })
  ),
  // The specific industry or topic domain is vital for improving accuracy.
  domain: Schema.Array(
    Schema.String.pipe(
      Schema.nonEmptyString(),
      Schema.annotations({
        description: "Individual domain/topic area"
      })
    )
  ).pipe(
    Schema.minItems(1),
    Schema.annotations({
      description: "The industries or topic domains of the media resource e.g. 'AI', 'Technology'"
    })
  ),
  speakers: Schema.Array(Speaker).pipe(
    Schema.minItems(1),
    Schema.annotations({
      description: "The speakers in the media resource e.g. 'John Doe', 'Jane Smith'"
    })
  ),
  language: LanguageCode,
  speakerCount: Schema.Int.pipe(
    Schema.positive(),
    Schema.annotations({
      description: "Number of speakers in the media resource"
    })
  ),
  durationSec: Schema.Number.pipe(
    Schema.positive(),
    Schema.annotations({
      description: "Duration of the media resource in seconds"
    })
  ),
  // represents any links found in the media resource (links in youtube description, etc.)
  links: Schema.Array(
    Schema.String.pipe(
      Schema.pattern(/^https?:\/\/.+/),
      Schema.annotations({
        description: "Individual link URL"
      })
    )
  ).pipe(
    Schema.annotations({
      description: "Links found in the media resource e.g. 'https://www.youtube.com/watch?v=dQw4w9WgXc'"
    })
  ),
  createdAt: Schema.Date
}).annotations({
  description: "Complete metadata extracted from media resources for transcription processing"
})
export type MediaMetadata = Schema.Schema.Type<typeof MediaMetadata>

// YouTube types are now consolidated in ./youtube.ts
// These types are imported above for MediaResource usage

export class YouTubeVideoResource extends Schema.Class<YouTubeVideoResource>("YouTubeVideoResource")({
  type: Schema.Literal("youtube"),
  id: MediaResourceId,
  metadata: MediaMetadata,
  data: YouTubeVideo
}) {}

export class YouTubeChannelResource extends Schema.Class<YouTubeChannelResource>("YouTubeChannelResource")({
  type: Schema.Literal("youtube-channel"),
  id: MediaResourceId,
  metadata: MediaMetadata,
  data: YouTubeChannel
}) {}

export const MediaResource = Schema.Union(
  Schema.Struct({
    type: Schema.Literal("youtube"),
    data: YouTubeVideo
  }),
  Schema.Struct({
    type: Schema.Literal("youtube#channel"),
    data: YouTubeChannel
  })
  // Future: add other media types like:
  // Schema.Struct({ type: Schema.Literal("spotify"), data: SpotifyTrack }),
  // Schema.Struct({ type: Schema.Literal("podcast"), data: PodcastEpisode }),
)
export type MediaResource = Schema.Schema.Type<typeof MediaResource>

// Legacy support - keeping the class-based resources for backward compatibility if needed
export const LegacyMediaResource = Schema.Union(
  YouTubeVideoResource,
  YouTubeChannelResource
)
